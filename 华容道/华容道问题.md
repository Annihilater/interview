# 华容道问题

> 经典搜索算法，回溯与剪枝讲解，深搜的实现及注意点，广搜的实现及注意点，深搜和广搜的使用场景解析。

题目：我有1到8八个数字，放在一个3x3的九宫格里面，那么会留下一个空格。

<img src="https://klause-blog-pictures.oss-cn-shanghai.aliyuncs.com/2019-11-07-092256.png" alt="image-20191107172256585" style="zoom:25%;" />

空格可以和上下左右的数字进行交换，你可以认为空格在移动。如果移动成

<img src="https://klause-blog-pictures.oss-cn-shanghai.aliyuncs.com/2019-11-07-092406.png" alt="image-20191107172405787" style="zoom:25%;" />

则游戏胜利。

你需要完成以下 2 件事情：

1. 给出数据结构来描述这个过程；
2. 给你一个初始状态，告诉我能不能胜利，并给出如何移动才能胜利。

> 这有点像中国的华容道游戏。



## 思路

快速找到最优解，应该使用广度搜索：

- 建立一个队列保存每一个搜索状态（搜索状态包括：当前表格的排列状态、上个状态到当前状态的搜索方向、上一个搜索状态）
- 每次从队列里取出队首状态（取出并删除），然后依次对上、下、左、右进行搜索
    - 每次搜索前都会判断当前状态是不是胜利状态，如果是，则直接返回
    - 搜索前判断是否可搜（设置判断条件），可搜的话就执行搜索
    - 搜索就是空格前进，空格前进操作包括两部分：
        - 两个格子的数据交换
        - 空格坐标变化
    - 空格坐标的 x，y 是二维数组的第一维和第二维，所以坐标系的建立应该是这样的
        ![image-20191114111750886](https://klause-blog-pictures.oss-cn-shanghai.aliyuncs.com/2019-11-14-035448.png)
    - 如果直到队列里的状态全部搜索完毕，那就说明不能取得胜利
- 胜利路径可以通过状态来获取，因为每一个状态都保存了上个状态到当前状态的方向，也保存了上个状态，这种数据结构相当于链表，倒序遍历出来就是胜利路径的倒序，再倒序一次就得到胜利路径
- 答案里用到了表示方向的二维数组，其实不用也可以，只是一种解决方式，使用二维数组理解起来有点绕，但是代码写起来会比较简单。方向二维数组的定义与表示4 个方向的顺序有关

```python
self.up = 0  # 向上
self.down = 1  # 向下
self.left = 2  # 向左
self.right = 3  # 向右

self.dxdy = [[-1, 0], [1, 0], [0, -1], [0, 1]]  # 辅助方向数组
```

方向数组构建解释：

- 上：从上面坐标系看，向**上**移动需要 `x - 1`，定义的 `self.up = 0`，意味着方向数组的首尾元素表示的是向上，首尾元素的 x 应该表示为 `-1`，向上的时候 y 坐标是不变的，所以首尾元素的 y 表示为 0
- 下：从上面坐标系看，向**下**移动需要 `x + 1`，定义的 `self.down = 1`，意味着方向数组的第二个元素表示的是向下，第二个元素的 x 应该表示为 `+1`，向上的时候 y 坐标是不变的，所以第二个元素元素的 y 表示为 0
- 左：从上面坐标系看，向**左**移动需要 `y - 1`，定义的 `self.left = 2`，意味着方向数组的第三个元素表示的是向左，第三个元素的 y 应该表示为 `-1`，向左的时候 x 坐标是不变的，所以第三个元素的 x 表示为 0
- 右：从上面坐标系看，向**右**移动需要 `y + 1`，定义的 `self.right = 3`，意味着方向数组的第四个元素表示的是向右，第四个元素的 y 应该表示为 `+1`，向右的时候 x 坐标是不变的，所以第四个元素的 x 表示为 0